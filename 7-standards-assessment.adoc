[[standards]]
== Assessment of OGC standards and community specifications

=== General remarks

This section assesses current OGC and other specifications with respect
to the identified requirements and analyses options for addressing the
requirements in an architecture for a next generation of OGC services
based on the approach taken by WFS 3.0.

This chapter is organized in three parts. First, we summarize how the different
XML and JSON encodings match the requirements. Second, we look at different
approaches to querying complex data and, third, we look at additional resource
types and other ways to organize and encode the data.

=== Encodings

The following table provides an overview of how the different feature encodings
for XML (GML, GML Simple Features Profile Level 0 and 2) and JSON (GeoJSON,
CityJSON) match the requirements regarding data structures identified in
the previous chapter.

CityJSON is, as the name implies, limited to 3D city models, provides a fixed schema
and is an implementation of the model that underpins CityGML in JSON.

.Comparison of XML and JSON encodings
[width="100%",cols="4,3,3,3,3,3",options="header"]
|=========================================================
|Requirement |GML, CityGML |GML-SF0 |GML-SF2 |GeoJSON |CityJSON
|multiple-values |Yes |No |Yes |Yes |Yes
|nested-structures |Yes |No |Yes |Yes |Yes, where necessary
|relationships |Yes |No |Yes |No |Yes
|multiple-geometries |Yes |Yes |Yes |No |Yes
|3D-geometries |Yes |No |No |No |Yes
|shared-geometries |Yes |No |No |No |No, only direct positions
|non-linear-interpolation |Yes |Arcs only |Arcs only |No |No
|schema-validation |Yes |Yes |Yes |Yes, but uncommon |Yes
|=========================================================

An issue with CityJSON is that there is no media type for CityJSON and the
generic `application/json` media type would have to be used, which may create
ambiguities with other potential JSON encodings for features in the future.

CityGML has no media type either, but CityGML is GML and the GML media type
can be used. However, if there are multiple GML encodings for the same dataset,
it would be necessary to register and use separate media types for each of
the GML encodings. I.e., OGC should consider to register a media type for
CityGML.

=== API building blocks for queries

Looking at extending the WFS 3.0 Core API with support for richer
queries, there are three different approaches:

1. Use an existing approach used in other OGC standards with support
for spatial queries,
2. use an existing approach used by the mainstream Web community that
is well-known to developers and well-supported,
3. specify a new query mechanism that is simple to implement.

Filter Encoding and Common Query Language (CQL) belong to the first category,
GraphQL and Falcor to the second category and the current discussions
in the development of the SpatioTemporal Asset Catalog (STAC) cite:[STAC]
are in the third category.

This could potentially be extended with additional options, including
(Geo)SPARQL, Gremlin, XQuery, etc. However, triple stores, graph databases or
XML databases are not the typical database backends used when publishing
spatial datasets for Web developers, so this analysis has focussed on the
other options mentioned above.

Another option that was mentioned as a candidate in discussion is OpenSearch including the
link:http://www.opengeospatial.org/standards/opensearchgeo[OpenSearch Geo/Time extensions].Â 
After starting to analyze the OpenSearch Geo/Time extension this does
not seem to be a real candidate. OpenSearch is more tailored towards
full-text searches, overlaps with WFS 3.0 (paging, etc), is XML-based
(OpenSearch descriptions, RSS/Atom as response formats) and the
OpenSearch descriptions overlap with the OpenAPI definitions. OpenSearch is,
therefore, not discussed in more detail.

To assess the options, the following aspects are considered:

* the capabilities to query spatial datasets based on the
requirements identified in the previous chapter;
* the suitability to support different encodings, in particular XML and JSON;
* the support for popular database backends, mainly relational databases and
document stores;
* support by libraries in key programming languages.

==== General considerations

This link:https://github.com/opengeospatial/WFS_FES/issues/79[GitHub issue] has
additional discussion that should be considered.

During the discussions at the WFS 3.0 hackathon in March 2018 there was agreement
that the path `/search/{endpoint}` should be reserved for offering richer queries
on a dataset. Different search implementations could be published as
separate search resources. i.e., a server could support multiple types of
queries in parallel. For example, `/search/fes` could be an endpoint for
WFS 2.0 ad-hoc queries with Filter Encoding 2.0 and `/search/graphql` could be
an endpoint for GraphQL queries on the same data.

In cases where only a query language is specified (e.g. WFS 2.0 ad-hoc queries
with Filter Encoding 2.0, CQL, XQuery, etc.), but no rules exist how to execute
queries via HTTP, there are three general options for the API design:

* Use of HTTP GET requests where the query is included in one or more query parameters.
* Use of HTTP POST requests where the query is included in one or more query parameters
in the payload with a media type of `application/x-www-form-urlencoded`.
* Use of HTTP POST requests with the query in the payload to create a new
query resource on the server. The request would return the URI of the new
query. Accessing the query URI with HTTP GET would return the result of the
query. HTTP PUT and DELETE could be used to update or delete the query.

The third option is quite heavy for queries that are not used repeatedly. For
queries that are executed more than once, however, this approach has benefits,
e.g. for caching. The approach would also support parameterized queries where
the parameters could be passed as query parameters when accessing the query
resource with a HTTP GET request (like stored queries in WFS 2.0).

==== WFS 2.0 ad-hoc queries and Filter Encoding 2.0

The OGC Filter Encoding Standard 2.0 cite:[FES20] is the standard
filter language for ad-hoc queries in WFS 2.0 cite:[WFS20]. Together they support
the query requirements identified in the previous chapter.

However, the specifications are closely tied to XML including the use of XPath,
which makes them an unnatural match for servers that want to return JSON.

Implementations exist, but the requirements identified in
the previous chapter are supported only to a limited extent in freely available
libraries. Implementations typically support relational database backends.

**Conclusion: A candidate query language for WFS 3.0 implementations that
also support WFS 2.0 and GML. Complex feature handling in WFS 3.0 will,
of course, only be supported, if the WFS 2.0 implementation already supports
the identified <<use_cases,use cases>>.**

[[cql]]
==== CQL

CQL is short for "OGC Common Query Language" and is defined in the
OGC Catalogue Services Standard 2.0 cite:[CS20] in section 6.2.2.
It is a text-based
syntax similar to the SQL "Where" clause, i.e. on a similar level as
Filter Encoding, but easier to write for most developers than the XML
syntax of Filter Encoding.

NOTE: The Catalog Service 3.0 also includes a syntax definition for CQL, but
lacks any rules or requirements for it. This report therefore references
version 2.0 of the standard.

Implementations typically support relational database backends,
CQL is less suited for document stores.

As a text-based query language it is not strongly tied to XML, JSON or any
other encoding.

CQL does not support all identified
query requirements. CQL does not have a well-defined semantics for
querying properties with multiple values, does not support link traversal
across relationships (query predicates on related features) or 3D geometries.

Implementations exist, but the requirements identified in
the previous chapter are only supported to a limited extent in freely available
libraries. An example is limited support for "compound attributes", i.e.
path expressions that might be used to query nested data structures.

Beside the fact that implementations support only a subset of the language, CQL
has a major limitation with respect to the requirements identified in the
<<analysis,previous chapter>>: Attribute values are assumed to be literal.
That is, CQL does not support values that are collections (maximum multiplicity > 1)
or objects / data types.

That is, either the use of CQL is restricted to feature data that meets these
constraints or CQL would need to be extended to support feature data that have the
following <<data_structures,data structure requirements>>:

* "multiple-values"
* "nested-structures"
* "relationships"

NOTE: Queries using solid geometries or non-linear curve interpolations are not
supported in CQL, but at least the <<use_cases, use cases>> did not identify
this as an important requirement.

For nested structures and relationships, probably the dot-notation the compound
attribute names could be used, but for each encoding the mapping between the
compound attribute names and the feature encoding would need to be specified.

For predicates on attributes with multiple values, there are basically two options:

* Add comparison operators that support collections and not just literal values.
* Follow the same approach as Filter Encoding 2.0 with the
link:http://docs.opengeospatial.org/is/09-026r2/09-026r2.html#50[matchAction]
parameter (where the default is that an expression evaluates to `true`, if at least
the expression evaluates to `true` for at least one of the attribute values).

In addition, the specification for time period expressions in CQL should be
amended to cover the cases discussed in the related
link:https://github.com/opengeospatial/WFS_FES/issues/155[WFS 3.0 issue].

In order to support clients to construct queries, the feature properties
that may be queried should be enumerated for each feature type. This could
be included in the feature collection metadata or, which is probably
preferable, it could be made available in an additional resource listing
all queryable properties. For example at `/collections/{collectionId}/queryables`.
The result could be a JSON object with a member for each property of the feature.
The value of the member could be used to identify the data type. If the
property value is a related object in the dataset, the queryables resource
of that collection could be referenced. For nested objects, the compound
attribute values could be used explicitly.

It should also be allowed to declare queryables that do not have to be, for
example, a direct member of the `properties` object in a GeoJSON feature.

CQL is currently "buried" in the Catalogue Service specification and the
specification of the language is largely restricted to the definition of the
grammar (with a number of inconsistencies and ambiguities in the definition).
If CQL would be supported by a WFS extension, it should be extracted from
the Catalogue Service standard and become a standard on its own, with a clear
and unambiguous specification of the language and requirements for
implementations.

**Conclusion: A candidate query language for an intermediate WFS 3.0
query capability that goes beyond the limited support that WFS 3.0 Core offers,
but that may not address all requirements identified. The lack of implementation
support for document stores is an issue that needs a broader discussion, too.**

[[cql-other-req]]
===== Supporting other requirements

There are three other requirements that are out-of-scope for CQL and which would
need to be covered by additional WFS 3.0 extensions:

[[resolve]]
* Requirement "embed-related-features": To add related features to the response,
another mechanism would have to be specified, independent of the CQL query.
For example, a query parameter `resolve` could be specified with a list of
feature-valued properties where the values should be included in the response,
if the related features are in the same dataset. +
This capability would be similar to the `resolvePath` attribute in WFS 2.0
with `resolve=local`.

[[properties]]
* Requirement "return-subset": To return only some of the properties another
query parameter, e.g. `properties`, could be used with a list of properties
that should be returned. The mapping between the names of the properties in
the query parameter and the feature encoding needs to be specified for each
encoding. In GeoJSON, for example, `id` and `geometry` are not part of the
properties JSON object, but should be supported, too. Similar in CityJSON where
the address information, the geometry or links to child features are encoded
separately from the attributes JSON object. +
This capability would be similar to the `propertyName` query parameter in
the WFS 2.0 KVP encoding.

[[items]]
* Requirement "query-multiple-collections": In addition to the `/collections/{collectionId}/items`
endpoint for each sub-collection in a dataset, an additional `/items` endpoint
could be added that provides access to features from all the sub-collections.
A query parameter `collections` could be added to access only features from
the listed collections in the response.

In the `resolve` and `properties` parameters, the same notation should be used for properties
of data types or related features as it is used by the compound attribute
names in CQL queries (see the discussion above).

[[cql-examples]]
===== Examples

Let's assume

* that CQL would be extended as described above,
* that the query parameters `resolve` and `properties` would be supported as described above,
* that a CQL query would be expressed on an `items` resource in a query parameter `where` and
* that an additional query parameter `where-lang` is used to support multiple languages for
`where` predicates (the examples below use `cql` for simpler expressions without
compound attributes etc. and `cql-extended` for expressions that require extensions
beyond a CQL Core as described above).

NOTE: Since CQL does not define a full query, but a "where" clause on a feature
collection, a separate `/search/cql` (or similar) endpoint is not necessary.

The queries in the <<uc-cadastre, cadastral use cases>> could be expressed as follows, assuming a GeoJSON feature encoding.

<<uc-select-association,Selection of protected sites>>:

.Query 1
----
/collection/ProtectedSite_Water/items?
where-lang=cql-extended&
where=contains.geometry INTERSECTS ENVELOPE(7.0244,7.1296,50.5351,51.4362)
----

.Query 2
----
/collection/ProtectedSite_Water/items?
where-lang=cql-extended&
where=contains.geometry INTERSECTS ENVELOPE(7.0244,7.1296,50.5351,51.4362)&
resolve=contains
----

<<uc-select-associations,Select the owners of cadastral parcels in an area>>:

.Query
----
/collection/Persons/items?
where-lang=cql-extended&
where=partOf.relatedTo.geometry INTERSECTS ENVELOPE(7.0348,7.0452,50.6252,50.7154) OR
      partOf.related.relatedTo.geometry INTERSECTS ENVELOPE(7.0348,7.0452,50.6252,50.7154)
----

The queryables at `/collection/{collectionId}/queryables` could be the following JSON
objects:

.Queryable properties of the features in the collection "Persons"
[source,JSON]
----
{
  "firstName": "String",
  "lastName": "String",
  "partOf": "http://example.com/cadastre/collection/Records/queryables",
  "lifespan.begin": "DateTime",
  "lifespan.end": "DateTime"
}
----

.Queryable properties of the features in the collection "Records"
[source,JSON]
----
{
  "recordId": "String",
  "right": "String",
  "related": "http://example.com/cadastre/collection/Records/queryables",
  "relatedTo": "http://example.com/cadastre/collection/CadastralParcels/queryables",
  "lifespan.begin": "DateTime",
  "lifespan.end": "DateTime"
}
----

.Queryable properties of the features in the collection "CadastralParcels"
[source,JSON]
----
{
  "parcelId": "String",
  "geometry": "Geometry",
  "lifespan.begin": "DateTime",
  "lifespan.end": "DateTime"
}
----

<<uc-versions,Select versions of cadastral parcels based on their temporal validity>>:

.Query
----
/collection/CadastralParcels/items?
where-lang=cql-extended&
where=lifespan.begin DURING 2017-07-01T00:00:00Z/2017-07-01T23:59:59Z
----

NOTE: The request could simply use `time=2017-07-01T00:00:00Z/2017-07-01T23:59:59Z`, too, which is already possible with WFS 3.0 Core.

<<uc-se,Select cadastral parcels for rendering with a specific style>>:

.Query
----
/collection/CadastralParcels/items?
where-lang=cql-extended&
where=denominator IS NOT NULL AND
      (altLegalStatus IS NULL OR altLegalStatus=false) AND
      textOnMap.type = 'ZAE_NEN'
----

NOTE: This ssumes that the interpretation of `textOnMap.type = 'ZAE_NEN'` is that at least one such value exists.

<<uc-select-buildingparts,Selection of building parts of a building>>:

.Query
----
/collection/CadastralParcels/items/DENW45AL0000lxrJ?
resolve=contains
----

NOTE: This requires that the topological relationship would be included in the feature data explicitly.

The feature queries in the <<uc-3d,3D / heating demand use cases>> could be expressed as follows, assuming a CityJSON feature encoding.

<<uc-byid,Using WFS to query the simulation result and visualize it in a 3D scene by building Id>>:

.Query
----
/ny_dataset/collection/buildings/items/uuid_2824afd6-00e5-42ac-ab95-ec868595dc5a?
properties=function,measuredHeight,heat
----

<<uc-byid2,Query a feature from a city model by id>>:

.Query
----
/my-city-model/collections/buildings/items/TWINHOUSE1
----

<<uc-select-buildings,Select buildings in a 2D region from a city model>>:

.Query
----
/my-city-model/collections/buildings/items?bbox=-74,40.7,-73.96,40.8
----

<<uc-nested-features-and-properties,Select buildings based on nested features or properties>>:

.Query 1
----
/my-city-model/collections/buildings/items?
where-lang=cql-extended&
where=geometry.lod2 INTERSECTS POLYGON(...)
----

NOTE: This assumes that the attribute `geometry.lod2` would map for a CityJSON encoding to the feature geometry with `lod: 2`

.Query 2
----
/my-city-model/collections/buildings/items?
where-lang=cql-extended&
where=address.ThoroughfareName LIKE 'Unter den Linden%'
----

NOTE: This assumes that the attribute `address.ThoroughfareName` would map for a CityJSON encoding to the `ThoroughfareName` member in the `address` JSON object).

The other queries from the use case are similar and are skipped here. In general, a pre-requisite is how attribute names map to the content of the CityJSON encoding.

NOTE: The 3DPS requests from the use cases are addressed <<scenes,here>>.

==== Falcor

Falcor cite:[Falcor] is a data platform that powers the Netflix user interfaces.

The starting point of Falcor is to assume that all data is a single
(virtual) JSON object. This allows clients to work with the data
using standard operations on JSON objects and support for Path expressions.
In the words of Netflix: "If you know your data, you know your API" cite:[WhatIsFalcor].

In a way this would be comparable to using XQuery as a query language
in WFS 2.0 where the dataset is basically a large GML feature collection.

Falcor has additional conventions to allow that the virtual JSON object can
be used as a graph with shared resources and not just the that a JSON object
is. This avoids multiple copies of the same object in different parts of
the virtual JSON object. An enhanced path notation is used to reference
nodes within the virtual JSON object.

Falcor has no schema of the data and assumes that the developer knows the
data (see the quote above).

It is mainly designed for use in JavaScript and has no support for
geometries or spatial predicates.

**Conclusion: Falcor may be a candidate for a WFS 3.0 implementation that
only supports JSON and that is mainly accessed from JavaScript. However,
support for spatial aspects would need to be specified and implemented first.
It is thus not considered in more detail in this report.**

==== GraphQL

GraphQL cite:[GraphQL] is a declarative, string-based query language created by Facebook to
support fetching data for use in a user application from a server.

NOTE: A similarity with Filter Encoding is the intent to be a
declarative language independent of the underlying database technology.

One of the main drivers for GraphQL was the goal to provide an interface that
allows mobile app developers to retrieve exactly the data that they need in
a single query from a single endpoint.
This is based on the observation that in REST APIs one usually
needs multiple requests to fetch the information and/or that the response
often contains unnecessary information ("overfetching").

That is, support for GraphQL would basically be complementary to the current
WFS 3.0 Web API. The blogpost "GraphQL: Everything You Need to Know" cite:[GraphQLPost]
includes a comparison of strengths and weaknesses of both approaches.

NOTE: A GraphQL endpoint could be implemented on
top of the Web API, but likely with sub-optimal performance.

Unlike Falcor, where the client has to know the data, GraphQL *requires* a
schema of the data. GraphQL is strongly typed and supports nesting,
multiplicities, etc.

Typically, GraphQL schemas are
tailored for the specific application needs. That is, GraphQL queries are in
practice in a way closer to the stored queries of WFS 2.0 than the
generic ad-hoc queries of WFS / FES 2.0 - although with a much richer
mechanism to specify parameters and projection clauses.

A significant plus for GraphQL is that it has a lively, and
growing, ecosystem with good tools, support, etc.

However, currently there is no support for geometries or
spatial queries in GraphQL.

GraphQL is not tied to JSON, but JSON seems to be by far the most commonly used
encoding.

**Conclusion: GraphQL is a promizing candidate because of its popularity and
its characteristics, in particular for usages that are close to end user
applications. Spatial support may be an issue and needs to be explored in more
detail, including the use of GeoJSON or CityJSON.**

[[graphql-example]]
===== An example query

We will use the data from <<uc-select-associations,one of our use cases>>
to explore how feature queries could be supported using GraphQL.

The first step is to define the schema of the relevant data. In general,
we could take two different approaches:

* define the schema so that the data returned by the queries contains valid GeoJSON
consistent with the feature data provided by the WFS; or
* define the schema so that it is tailored towards the query needs.

The first approach is closer to WFS and simplifies the reuse of the query
results in contexts where GeoJSON objects can be processed directly. The second approach
is closer to pre-defined stored queries, with new data structures derived from
the feature data.

In this testbed we will explore only to the first approach (since in the second
approach it is difficult to see what could be specified in a WFS-related standard).

Here is how a GraphQL schema could look like for the features in the use
case:

.GraphQL schema for Person, Record and CadastralParcel features
----
interface GeoJSONObject {
  id: ID!
  type: GeoJSONType!
}

enum GeoJSONType {
  Point
  MultiPoint
  LineString
  MultiLineString
  Polygon
  MultiPolygon
  GeometryCollection
  Feature
  FeatureCollection
}

type Person implements GeoJSONObject {
  id: ID!
  type: GeoJSONType!
  properties: PersonProperties
}

type PersonProperties {
  firstName: String
  lastName: String
  partOf: [Record]
}

type Record implements GeoJSONObject {
  id: ID!
  type: GeoJSONType!
  properties: RecordProperties
}

type RecordProperties {
  right: RightType
  relatedTo: [CadastralParcel]!
}

enum RightType {
  SomeRight
  AnotherRight
  YetAnotherRight
}

type CadastralParcel implements GeoJSONObject {
  id: ID!
  type: GeoJSONType!
  geometry: GeoJSONMultiSurface
  properties: CadastralParcelProperties
}

type GeoJSONMultiSurface {
  type: GeoJSONType!
  coordinates: [[[[Float]]]]
}

type CadastralParcelProperties {
  parcelNumber: String
  area(unit: AreaUnit = m2): Float
  records: [Record]
}

enum AreaUnit {
  m2
  ft2
}

# the schema allows the following queries:
type Query {
  parcels: [CadastralParcel]
  person(id: String!): Person
}
----

Let's assume we have the following data instances:

.Sample data
[source,JSON]
----
{
  "persons": [
    { "type": "Feature", "id": "1", "properties": { "firstName": "John", "lastName": "Doe", "partOf": [ "1" ] } },
    { "type": "Feature", "id": "2", "properties": { "firstName": "Erika", "lastName": "Mustermann", "partOf": [ "2", "3", "4" ] } },
  ],
  "records": [
    { "type": "Feature", "id": "1", "properties": { "right": "SomeRight", "relatedTo": [ "DENW19AL0000geMFFL" ] } },
    { "type": "Feature", "id": "2", "properties": { "right": "SomeRight", "relatedTo": [ "DENW19AL0000genyFL" ] } },
    { "type": "Feature", "id": "3", "properties": { "right": "AnotherRight", "relatedTo": [ "DENW19AL0000geqyFL" ] } },
    { "type": "Feature", "id": "4", "properties": { "right": "YetAnotherRight", "relatedTo": [ "DENW19AL0000geqyFL", "DENW19AL0000ger1FL" ] } }
  ],
  "parcels": [
    { "type": "Feature", "id": "DENW19AL0000geMFFL", "properties": { "parcelNumber": "193", "area": 1739.0 }, "geometry": { "type" : "MultiPolygon", "coordinates" : [ [ [ [ 8.711910494386446, 51.49108376876667 ], [ 8.71229996279325, 51.491067136843 ], [ 8.71238480759279, 51.49164525475229 ], [ 8.712013831642468, 51.491666041604 ], [ 8.711993473544684, 51.4916028694182 ], [ 8.711960339932295, 51.49139558179017 ], [ 8.711953300233393, 51.49135154980474 ], [ 8.711910494386446, 51.49108376876667 ] ] ] ]} },
    { "type": "Feature", "id": "DENW19AL0000genyFL", "properties": { "parcelNumber": "174", "area": 4533.0 }, "geometry": { "type" : "MultiPolygon", "coordinates" : [ [ [ [ 8.697513007025446, 51.50144133282769 ], [ 8.697820179888327, 51.50128890506469 ], [ 8.699285444473853, 51.50252385737269 ], [ 8.698973376983412, 51.50259426261686 ], [ 8.698937901399875, 51.5026408567456 ], [ 8.698295428101916, 51.50210001561205 ], [ 8.697513007025446, 51.50144133282769 ] ] ] ] } },
    { "type": "Feature", "id": "DENW19AL0000geqyFL", "properties": { "parcelNumber": "74", "area": 10175.0 }, "geometry": { "type" : "MultiPolygon", "coordinates" : [ [ [ [ 8.686673298571343, 51.50079992000421 ], [ 8.68679160662328, 51.50074125004235 ], [ 8.687436267676059, 51.50042151431735 ], [ 8.688147581070762, 51.500903657307006 ], [ 8.688887649073012, 51.50140520447189 ], [ 8.688883177902552, 51.50143555777073 ], [ 8.688149161509205, 51.50179930330681 ], [ 8.68738593229976, 51.50128249372289 ], [ 8.686673298571343, 51.50079992000421 ] ] ] ] } },
    { "type": "Feature", "id": "DENW19AL0000ger1FL", "properties": { "parcelNumber": "103", "area": 6894.0 }, "geometry": { "type" : "MultiPolygon", "coordinates" : [ [ [ [ 8.688736032883249, 51.5036400173296 ], [ 8.689168817396284, 51.50342556070846 ], [ 8.689822053323931, 51.50386836226231 ], [ 8.690374046734465, 51.504242519669305 ], [ 8.690927010128721, 51.50461732440779 ], [ 8.690749468566104, 51.50470536227641 ], [ 8.690494250855838, 51.50483185947567 ], [ 8.689649601209783, 51.50425930806056 ], [ 8.688736032883249, 51.5036400173296 ] ] ] ] } }
  ]
}
----

The following GraphQL query would return selected information about the parcels
on which the person with id "2" has rights.

.Sample GraphQL query
----
query ParcelsForPerson {
  person(id: "2") {
    properties {
      firstName
      lastName
      partOf {
        properties {
          right
          relatedTo {
            id
            properties {
              area
              parcelNumber
            }
          }
        }
      }
    }
  }
}
----

The query requests the following information in the result:

* the first and last name of the person;
* the right for each cadastral record that is associated with the person;
* the parcels for each of the cadastral records (the identifier, the parcel number and the parcel area).

All other properties, including the geometries are suppressed in the query
result.

.Query result
[source,JSON]
----
{
  "data": {
    "person": {
      "properties": {
        "firstName": "Erika",
        "lastName": "Mustermann",
        "partOf": [
          {
            "properties": {
              "right": "SomeRight",
              "relatedTo": [
                {
                  "id": "DENW19AL0000genyFL",
                  "properties": {
                    "area": 4533,
                    "parcelNumber": "174"
                  }
                }
              ]
            }
          },
          {
            "properties": {
              "right": "AnotherRight",
              "relatedTo": [
                {
                  "id": "DENW19AL0000geqyFL",
                  "properties": {
                    "area": 10175,
                    "parcelNumber": "74"
                  }
                }
              ]
            }
          },
          {
            "properties": {
              "right": "YetAnotherRight",
              "relatedTo": [
                {
                  "id": "DENW19AL0000geqyFL",
                  "properties": {
                    "area": 10175,
                    "parcelNumber": "74"
                  }
                },
                {
                  "id": "DENW19AL0000ger1FL",
                  "properties": {
                    "area": 6894,
                    "parcelNumber": "103"
                  }
                }
              ]
            }
          }
        ]
      }
    }
  }
}
----

The example has been set up in an Apollo GraphQL
Launchpad and you can play with different queries: https://launchpad.graphql.com/07v1j3zzm5.

From the example, we can derive some topics for discussion and further
experimentation:

* The use of the `properties` object in GeoJSON results in quite complex
schemas and results. It would be more natural in the queries, if the
properties would be members of the feature object instead of being nested
in a sub-object.
* To be a valid GeoJSON feature, the JSON object must have a `geometry` member,
which may be `null`. It is not possible to simply drop the member
from the result. As a consequence, the feature objects in the result above
are not valid GeoJSON features.
* GeoJSON-aware software probably does not expect nested GeoJSON features
anyhow.

It is, therefore, questionable, if there is value in using GeoJSON in the
GraphQL schema. It seems quite likely that a tailored GraphQL schema for the
specific query needs would be better suited. This requires more experiments
and further work.

With CityJSON as an encoding this should be even more of an issue due to
the distributed way in which geometry and properties are encoded across the
JSON document.

==== Queries in the SpatioTemporal Asset Catalog (STAC)

The SpatioTemporal Asset Catalog (STAC) specification cite:[STAC] intends to
standardize the way geospatial assets are exposed online and queried. The
specification defines *spatiotemporal asset* as "any file that represents
information about the earth captured in a certain space and time". Right now,
the focus is on remotely-sensed imagery.

Querying STAC is very similar to general feature querying and since the
principles and technologies used are very similar, the WFS 3.0 hackathon in
March 2018 cite:[WFS3hackathon] was co-located with a STAC
sprint cite:[STAC-FtCollins]. During these meetings the API building blocks
were aligned so that STAC implementations will conform to WFS 3.0 Core.

STAC extends the Core with a `/search/stac` endpoint, which for now is restricted
to bounding box and time interval searches like WFS 3.0 Core.

Several ideas are discussed or explored for supporting more advanced queries:

* The link:https://github.com/radiantearth/stac-spec/blob/master/roadmap.md#querying-and-filtering[STAC roadmap]
mentions link:https://github.com/geotools/geotools/blob/master/modules/library/cql/ECQL.md[ECQL] - a variant of
CQL ("a CQL Like language") implemented in GeoTools - and
link:http://backand-docs.readthedocs.io/en/latest/apidocs/nosql_query_language/index.html[Backand NOSQL query language]
as options.
* In Fort Collins, a JSON encoding of a query filter was presented and discussed.
This development continues, see these
link:https://github.com/radiantearth/stac-spec/blob/dev/api-spec/extensions/query.fragment.yaml[OpenAPI fragments for a query extension].

NOTE: Another STAC extension related to the <<use_cases in this document,use cases>> is a capability to link:https://github.com/radiantearth/stac-spec/blob/dev/api-spec/extensions/fields.fragment.yaml[shape the feature properties to be included in the response].

**Conclusion: Before any decision is made for WFS 3.0 query extensions, the
plans should be discussed with the STAC community to check for additional
opportunities to align the specifications.**

==== Summary

The following table summarizes in how far the candidates support the identified
requirements.

.Comparison of candidate query languages
[width="100%",cols="4,3,3,3,3",options="header"]
|=========================================================
|Requirement |WFS 2.0 + FES |CQL |GraphQL |STAC JSON
|query-properties-with-multiple-values |Yes |No |Yes |No
|query-nested-properties |Yes, but limited support in implementations |Yes, but limited support in implementations |Yes |No
|query-logical-operators |Yes |Yes |Yes |Yes
|query-2D-geometries |Yes |Yes |No |Yes
|query-buffers |Yes |Yes |No |No
|query-3D-geometries |Yes |No |No |No
|query-current-data |n/a |n/a |Yes, this can be implemented in the query definitions |n/a
|embed-related-features |Yes |n/a, but see <<cql-other-req,here>>  |Yes |No
|return-subset |Yes, but with limitations |n/a, but see <<cql-other-req,here>>  |Yes |Yes
|query-multiple-collections |Yes |n/a, but see <<cql-other-req,here>>  |Yes |Yes
|=========================================================

=== API building blocks for additional resource types

==== Tiles (2D)

For 2D data, a commonly used approach is to organize the feature data in tiles,
in particular for visualization in map-based client applications in a web
browser. Tiles are
provided for different zoom levels (scales) and how the features that are
located in the bounding box of a tile are included in the tile will depend
on the zoom level (e.g. no buildings at a scale of 1:1.000.000).

In parallel to OGC Testbed 14 another OGC Innovation Program initiative, the
Vector Tiles Pilot, is investigating how Vector Tiles should be provided via
a NextGen service Web API as Mapbox Vector Tiles (using Google Protocol Buffers)
and as GeoJSON. Of course, the tiles could also be rendered as bitmap images, too,
if the server has styling information.

In general, as tiles are different resources, they would be made available under
new resource paths. For example:

* `/collections/{collectionId}/tiles/{tilingScheme}/{zoomLevel}/{row}/{column}`: Tiles with features of a single collection.
* `/tiles/{tilingScheme}/{zoomLevel}/{row}/{column}`: Tiles with feature data from
multiple collections / with multiple layers. Like in the case of the `/items` path
proposed above, a query parameter `collections` should be added to access only
features from a selected list of collections in the response.

These paths (in addition to paths for the tiling scheme information) represent
the capabilities of an OGC WMTS in a NextGen architecture.

In addition, Google Protocol Buffers following the Mapbox Vector Tile format
could also be served from the `/collections/{collectionId}/items` path as an
additional encoding. A pre-requisite is a media type for the encoding to support
content negotiation.

[[scenes]]
==== Scenes (3D)

A common approach to provide optimized access to 3D feature data for visualization
in a browser are "scenes". A scene provides 3D geometries with texture data and attribute
information, organized as a scene graph and/or spatial index. Each node in the graph
represents a spatial partition and data for display at a certain level of detail,
depending on the distance from the viewpoint, etc.

The OGC 3DPS standard cite:[_3DPS] provides access to scenes, usually using the
OGC community specifications i3s cite:[i3s] and 3D Tiles cite:[_3DTiles].

A difference to the 2D tiles case described in the previous section is that it is
the client that requests tiles for display based on the knowledge of the tiling scheme.
In the 3DPS case, the nodes in the scene graph are secondary resources, linked from
the scene graph. That is, the client accesses a scene graph and then access the nodes
linked from the graph.

A possible implementation for fetching scenes of a dataset in a NextGen
architecture could be

* `/collections/{collectionId}/scene`: A scene with features of a single collection.
* `/scene`: A scene with feature data from multiple collections / with multiple layers.
Again, a query parameter `collections` should be added to access only
features from a selected list of collections in the response (in 3DPS 1.0: `layers`).

NOTE: It is important to understand the difference to the `tiles` paths above.
These represent enumerable resources (the tiles). The `scene`
paths are different, they represent a single processing resource that derives a scene
from the collection or dataset based on the requested characteristics. Therefore,
plural is used for `tiles` and singluar for `scene`. +

NOTE: Supporting WMS capabilities in the NextGen architecture could follow the
same approach, i.e. to support `/collections/{collectionId}/map` and `/map`
resources.

The `scene` paths should support the usual WFS 3.0 query parameters:

* `bbox` (in 3DPS 1.0: `boundingbox`),
* `time` (in 3DPS 1.0: not supported),
* `crs` (from the WFS 3.0 CRS extension, in 3DPS 1.0: `crs`)
* `bbox-crs` (from the WFS 3.0 CRS extension, in 3DPS 1.0: part of `boundingbox`)
* `properties` (proposed above, for scene encodings that support feature properties, in 3DPS 1.0: not supported)
* `where` (proposed above, in 3DPS 1.0: not supported)

The last two parameters would be up for discussion, but in general it should
be helpful for clients, if feature selection is done consistently across
the different resources in the API.

In addition, the other parameters of the GetScene request (beside `request`,
`version` and `format` which are no longer needed as this is handled
differently) would be supported, too. For example, `lods` or `styles`.


~~It is planned by HFT to implement an experimental 3D Portrayal Service scene
resource following this approach based on the Testbed 13 showcase using the
3D CityGML model of New York described <<uc-3d,here>>. The request~~


Steinbeis Transfer Center at HFT Stuttgart (Steinbeis) has implemented an experimental 3D Portrayal Service scene
resource following this approach based on the Testbed 13 showcase using the
3D CityGML model of New York described http://docs.opengeospatial.org/per/17-046.html[here]. The implementations is based on openAPI and the REST API can be tested http://steinbeis-3dps.eu:8080/tb14/API/index.html[http://steinbeis-3dps.eu:8080/tb14/API/index.html].  

Alternatively, to use the call in your application make the following request by defining the correct **bbox** coordinates~~

----
 http://steinbeis-3dps.eu:8080/tb14/wfs3/3D_CityModel_manhattan/collections/buildings/scene?format=application/json&bbox=-73.99562241015136,40.72227595290325,-73.9799164993194,40.749273379993284
----

The aforementioned call will deliver a 3D building model (as one layer of the 3D city model (3D-DLM))
of Manhattan using 3D Tiles. It can be rendered in the Cesium globe. A prototype implemetation can be accessed (http://81.169.187.7:8081/3DPS_App/)

image::images/3dps6.png

The current implementation supports two functionalities **Data Layer** and **3D Scene** (See Fig. xxx). 
image::images/3dps1.png

The data Layer function is 
used to retrieve the name of the available data layers. The implementation supports one layer only:  â3D_CityModel_manhattanâ . However in case the service supports more then one data layer will be a list of supported data layers (eg. {âdatalayer â: â3D_CityModel_manhattan,3D_CityModel_geneva,3D_CityModel_stuttgart"}. The REST API call can be tested by first clicking on the _Try it out_  button and then _execute_ button. 

image::images/3dps2.png
Since the call does not take any input you will see the output as shown in Fig xxx. In addition, it also shows the curl request with all the necessary query parameters.




The 3D Scene function takes three input. The first is the path parameter(layer) and the remaining two are query parameters(format,bbox) see Fig

image::images/3dps3.png


Successful execution will provide the a tilesetlink (see example below)
  {
{"tilesetLink" ::"http://tb13.igd.fraunhofer.de:8083/3dps/datahoster/fc38b549-4989-4703-bb27-f5b4fd33fd90/manhattan/tileset.json"}


This tilesetLink can be rendered in the Cesium globe. To show the feasibility of our approach we have developed a prototype see Fig xxx. Please visit the following http://81.169.187.7:8081/3DPS_App/[ http://81.169.187.7:8081/3DPS_App/]. 

You can also visit the you tube link https://www.youtube.com/watch?v=6EwlwAhtK7Q[https://www.youtube.com/watch?v=6EwlwAhtK7Q] to educate yourself how to use the platform.


To include multiple layers (for example, buildings and vegetation), the request
would be:

----
../3D_CityModel_manhattan/scene?collections=buildings,vegetation&bbox=-74.0064,40.7178,-73.9739,40.7507
----

The information that is currently included in 3DPS 1.0 capabilities would be
included in the OpenAPI document and in extensions to the feature collection
metadata resources like in WFS 3.0.

[[media-types]]
The selection of an encoding would follow the same approach as
link:https://rawgit.com/opengeospatial/WFS_FES/master/docs/17-069.html#_encodings_2[in WFS 3.0].
That is, every server will support content negotiation using media types to negotiate
the format of the response. In addition, servers should support a mechanism to
include the format information in the path to support hyperlinks.

Media types for i3s and 3D Tiles are an open issue.

For i3s `application/vnd.esri.i3s.json+gzip` is specified, but not registered with IANA yet.

For 3D Tiles no specific media type has been specified yet and
link:https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#file-extensions-and-mime-types[general media types are used]
(in particular `application/json`). This should be changed as the use of the
general media types is ambiguous.

==== Other 3DPS requests

In addition to scenes, the 3DPS 1.0 standard cite:[_3DPS] specifies additional
requests that would need to be mapped, too. A detailed analysis is out-of-scope
for this report, but from looking at the feature info requests we can see the
benefits of the NextGen architecture that allows to support the different
resources derived from a dataset in a single API. Where 3DPS 1.0 has to define
its own requests to access feature data, in the NextGen architecture these resources
are often already provided by the API building blocks specified by WFS 3.0.

`GetFeatureInfoByObjectId` in 3DPS 1.0, for example, is an operation that allows a client
to retrieve information about features that are selected based on object identifiers.
In the NextGen architecture this is simply the paths
`/collections/{collectionId}/items/{featureId}` specified by WFS 3.0 Core.

On the other hand `GetFeatureInfoByRay` introduces a new way of spatially selecting
features based on a virtual ray. In the NextGen architecture this would
be implemented in an extension to the WFS 3.0 `/collections/{collectionId}/items`
resource where additional query parameters specify the ray.
